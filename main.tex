\documentclass[10pt, a3paper, landscape]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{ragged2e} % Für besseren Textumbruch in X-Spalten

% Seitenränder anpassen für maximale Ausnutzung
\geometry{left=1.2cm, right=1.2cm, top=1cm, bottom=1cm, landscape}

% --- C++ Style for listings ---
\lstdefinestyle{cpp_style}{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{purple},
    commentstyle=\color{gray},
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    showstringspaces=false,
    backgroundcolor=\color{lightgray!10} % A very light gray background
}
\lstset{style=cpp_style}

% Eigene Befehle für Hervorhebungen
\newcommand{\formel}[1]{\ensuremath{#1}}
\newcommand{\algo}[1]{\textbf{\textcolor{blue!60!black}{#1}}}
\newcommand{\datastruct}[1]{\textbf{\textcolor{red!60!black}{#1}}}
\newcommand{\SubItem}[1]{
    {\setlength\itemindent{15pt} \item[-] #1}
}

\setlist{nosep, leftmargin=*}
\setlength{\columnsep}{0.7cm}

\pagestyle{empty}

\begin{document}
\begin{multicols*}{4}

\section{Typumwandlung}

\begin{itemize}
    \item \datastruct{Implicit Casting}: Automatische Typumwandlung durch den Compiler.
    \begin{itemize}
        \item \lstinline|int a = 5.4;| $\implies$ a wird zu einem int (5)
        \item \lstinline|float b = 7/2;| $\implies$ Ganzzahlige Division, Ergebnis 3 wird zu double (3.0)
        \item \lstinline|float c = 7/2.0;| $\implies$ Einer der Werte ist float, Ergebnis 3.5
        \item \lstinline|double d = 'A' - 12;| $\implies$ char wird zu int (65), dann - 12 (53), dann zu double (53.0)
        \item \lstinline|int e = true + 3;| $\implies$ bool wird zu int (1) + 3 (4), dann zu int (4)
        \item Allgemein: \textit{Der kleinere Typ wird in den größeren umgewandelt}
    \end{itemize}

    \item \datastruct{Explicit Casting}: Manuelle Typumwandlung durch den Programmierer.
    \begin{itemize} 
        \item \lstinline|int x = (int)3.7;| $\implies$ Klassischer Cast: Ergebnis ist 3
        \item \lstinline|int y = static_cast<int>(3.7);| $\implies$ Moderner Cast mit \lstinline|static_cast|: Ergebnis ist ebenfalls 3
    \end{itemize}
\end{itemize}

\section{Hierarchie von Operatoren}

\noindent % Verhindert Einrückung
\begin{tabularx}{\linewidth}{l l >{\RaggedRight}X}
\toprule
\textbf{Priorität} & \textbf{Operator} & \textbf{Beschreibung} \\
\midrule
\textbf{Hoch}      & \texttt{!} \texttt{*} \texttt{\&} & \textbf{Unär:} Log. NICHT, Deref., Adresse \\
$\downarrow$       & \texttt{*} \texttt{/}  & \textbf{Binär:} Multiplikation, Division \\
$\downarrow$       & \texttt{+} \texttt{-}  & \textbf{Binär:} Addition, Subtraktion \\
$\downarrow$       & \texttt{<<} \texttt{>>} & \textbf{Binär:} Bit-Shift Links/Rechts \\
$\downarrow$       & \texttt{\&}             & \textbf{Binär:} Bitweises UND \\
$\downarrow$       & \texttt{|}             & \textbf{Binär:} Bitweises ODER \\
$\downarrow$       & \texttt{\&\&}            & \textbf{Binär:} Logisches UND \\
\textbf{Niedrig}   & \texttt{||}            & \textbf{Binär:} Logisches ODER \\
\bottomrule
\end{tabularx}

\section{Wertebereiche von Datentypen}

\noindent
\begin{tabularx}{\linewidth}{l l >{\RaggedRight}X}
\toprule
\textbf{Datentyp} & \textbf{Bytes} & \textbf{Wertebereich} \\
\midrule
\lstinline|bool| & 1 & \texttt{true} oder \texttt{false} \\
\lstinline|char| & 1 & -128 bis 127 \\
\lstinline|unsigned char| & 1 & 0 bis 255 \\
\lstinline|short| & 2 & -32.768 bis 32.767 \\
\lstinline|unsigned short| & 2 & 0 bis 65.535 \\
\lstinline|int| & 4 & -2.147.483.648 bis 2.147.483.647 \\
\lstinline|unsigned int| & 4 & 0 bis 4.294.967.295 \\
\lstinline|long long| & 8 & ca. -9,2 x 10$^{18}$ bis 9,2 x 10$^{18}$ \\
\lstinline|float| & 4 & ca. $\pm$3.4 x 10$^{38}$ (7 Dezimalstellen) \\
\lstinline|double| & 8 & ca. $\pm$1.8 x 10$^{308}$ (15 Dezimalstellen) \\
\bottomrule
\end{tabularx}

\section{Overflow von Zahlen}
Overflow = Zugewiesene oder berechnete Zahl liegt außerhalb des darstellbaren Bereichs eines Datentyps.
\begin{itemize}
    \item \datastruct{Ganzzahlen}: Undefiniertes Verhalten. z.B. zu hohe Bits werden abgeschnitten oder es wird auf den Minimalwert zurückgesetzt.
    \item \datastruct{Gleitkommazahlen}: Im IEEE 754 Standard wird bei Overflow der Wert \texttt{inf} (unendlich) zugewiesen.
\end{itemize}

\section{Definition und Deklaration}
\begin{itemize}
    \item \algo{Definition}: Reserviert Speicherplatz für eine Variable oder Funktion und kann optional initialisiert werden.
    \begin{itemize}
        \item Beispiel Variable: \lstinline|int x = 5;|
    \end{itemize}
    \item \datastruct{Deklaration}: Informiert den Compiler über den Typ und Namen einer Variable oder Funktion, reserviert aber keinen Speicherplatz.
    \begin{itemize}
        \item Beispiel Variable: \lstinline|int x;|
        \item Beispiel Funktion: \lstinline|void foo();|
    \end{itemize}
    \item \datastruct{Prototyp}: Funktionsdeklaration ohne Funktionskörper.
    \begin{itemize}
        \item Beispiel: \lstinline|int map(double[], int, int (*)(double));|
    \end{itemize}
    \item \algo{Wichtig}: \textit{Jede Definition ist auch eine Deklaration!}
\end{itemize}

\section{String und Vector API}

\noindent
\begin{tabularx}{\linewidth}{l l >{\RaggedRight}X}
\toprule
\textbf{Typ} & \textbf{Methode} & \textbf{Beschreibung} \\
\midrule
\texttt{string/vector} & \lstinline|.size()| / \lstinline|.length()| & Gibt die Anzahl der Elemente bzw. die Länge zurück \\
\texttt{string/vector} & \lstinline|.empty()| & Prüft, ob leer \\
\texttt{string/vector} & \lstinline|.clear()| & Löscht den Inhalt \\
\texttt{string} & \lstinline|.append(str)| & Fügt \lstinline|str| am Ende an (auch \lstinline|+=| möglich) \\
\texttt{vector} & \lstinline|.push_back(val)| & Fügt \lstinline|val| am Ende hinzu \\
\texttt{vector} & \lstinline|.pop_back()| & Entfernt das letzte Element \\
\texttt{string/vector} & \lstinline|.at(idx)| & Gibt Element/Zei­chen an Position \lstinline|idx| zurück \\
\texttt{string/vector} & \lstinline|.front() / .back()| & Erstes/letztes Element zurückgeben \\
\texttt{string/vector} & \lstinline|.begin() / .end()| & Iteratoren auf Anfang/Ende \\
\texttt{string} & \lstinline|.substr(start, len)| & Teilstring ab \lstinline|start| mit Länge \lstinline|len| \\
\texttt{string} & \lstinline|.find(str)| & Sucht nach \lstinline|str| und gibt Startposition zurück \\
\bottomrule
\end{tabularx}

\section{Nützliche std:: Funktionen}
Benötigt \lstinline|#include <algorithm>| und \lstinline|#include <functional>|
\newline 
\newline 
\noindent
\begin{tabularx}{\linewidth}{l >{\RaggedRight}X}
\toprule
\textbf{Methode} & \textbf{Beschreibung} \\
\midrule
\lstinline|std::sort(b, e)| & \lstinline|void|  Sortiert einen Bereich \\
\lstinline|std::find(b, e, v)| & \lstinline|Iterator|  Sucht einen Wert im Bereich \\
\lstinline|std::reverse(b, e)| & \lstinline|void|  Dreht die Reihenfolge im Bereich um \\
\lstinline|std::max(a, b)| & \lstinline|T|  Gibt das größere von zwei Werten zurück \\
\lstinline|std::find_if(b, e, p)| & \lstinline|Iterator|  Sucht das erste Element, das das Prädikat erfüllt \\
\lstinline|std::count_if(b, e, p)| & \lstinline|int|  Zählt Elemente, die das Prädikat erfüllen \\
\lstinline|std::all_of(b, e, p)| & \lstinline|bool|  Prüft, ob alle Elemente das Prädikat erfüllen \\
\lstinline|std::any_of(b, e, p)| & \lstinline|bool|  Prüft, ob mindestens ein Element das Prädikat erfüllt \\
\lstinline|std::max_element(b, e)| & \lstinline|Iterator|  Gibt den Iterator auf das größte Element im Bereich zurück \\
\lstinline|std::min_element(b, e)| & \lstinline|Iterator|  Gibt den Iterator auf das kleinste Element im Bereich zurück \\
\lstinline|std::for_each(b, e, f)| & \lstinline|void|  Wendet Funktion \lstinline|f| auf jedes Element im Bereich an \\

\bottomrule
\end{tabularx}

\begin{itemize}
    \item \lstinline|b| = \lstinline|begin()|, \lstinline|e| = \lstinline|end()|
    \item \lstinline|p| = Prädikat (Funktion, die bool zurückgibt) z.B. \lstinline|[](int x){return x>5;}|
    \item \lstinline|v| = Wert, der gesucht wird
    \item \lstinline|d| = Zieliterator (z.B. Anfang eines anderen Containers)
    \item \lstinline|f| = Funktion, die auf jedes Element angewendet wird (z.B. \lstinline|[](int x){return x*2;}|)
\end{itemize}

\section{Konventionen}

\begin{itemize}
\item \datastruct{Zugriffsmodifikatoren}: Reihenfolge: \lstinline|public:|, \lstinline|protected:|, \lstinline|private:|
\item \datastruct{Konstruktoren}: Immer Explicit angeben 
\item \datastruct{Destruktoren}: Immer Virtual angeben, wenn die Klasse vererbt wird
\item \datastrunct{Membervariablen}: Immer mit \lstinline|m_| oder \lstinline|_m| kennzeichnen. Keine gleichen Namen wie Parameter im Konstruktor verwenden.
\item \datastruct{Funktionen / Methoden}: Nicht komplett inline definieren: \lstinline|int add(int a, int b) {return a+b}|
\item \datastruct{Void als Parameter}: Nie \lstinline|void| als Parameter verwenden: \lstinline|int foo(void);|
\end{itemize}

\section{Objektorientierung}

\begin{itemize}
   \item \datastruct{Konstruktor / Destruktor}: Konstruktoren werden in verschachtelten Klassen von der innersten zur äußersten Klasse aufgerufen. Destruktoren in umgekehrter Reihenfolge.
   \item \datastruct{Virtual / Overrite}: Virtuelle Funktionen werden in der Basisklasse mit \lstinline|virtual| deklariert und in der abgeleiteten Klasse mit \lstinline|override| überschrieben.
   \begin{itemize}
        \item Wenn eine Methode als \lstinline|virtual| deklariert ist, wird zur Laufzeit die passende Methode der abgeleiteten Klasse aufgerufen, auch wenn der Zeiger oder die Referenz den Typ der Basisklasse hat.
        \item Wenn eine Methode nicht als \lstinline|virtual| deklariert ist, wird die Methode abhängig vom Typ des Zeigers oder der Referenz aufgerufen (statischer Bindung).
   \end{itemize}
    \item \datastruct{Final}: Mit \lstinline|final| kann verhindert werden, dass eine Klasse weiter vererbt wird oder eine Methode überschrieben wird.
\end{itemize}

\section{Smart Pointer}

Smart Pointer sind Klassen, die die Verwaltung von dynamisch allozierten Objekten übernehmen und automatisch den Speicher freigeben, wenn der Pointer nicht mehr benötigt wird.

\begin{itemize}
    \item \lstinline|std::unique_ptr<T>|: Besitzt ein Objekt exklusiv. Kann nicht kopiert, nur verschoben werden. Nutzt \lstinline|std::move()| zum Übertragen des Besitzes.
    \item \lstinline|std::shared_ptr<T>|: Teilt den Besitz eines Objekts mit anderen \lstinline|shared_ptr|s. Verwendet Referenzzählung, um zu wissen, wann das Objekt gelöscht werden kann.
\end{itemize}

\newline\newline
\subsection*{make\_shared / make\_unique}

Empfohlene Methode zur Erstellung von Smart Pointern, da sie effizienter und sicherer ist als die direkte Verwendung von \lstinline|new|.

\begin{itemize}
    \item \lstinline|auto ptr = std::make_unique<T>();|: Erstellt einen \lstinline|unique_ptr| zu einem neuen Objekt vom Typ \lstinline|T|.
    \item \lstinline|auto ptr = std::make_shared<T>();|: Erstellt einen \lstinline|shared_ptr| zu einem neuen Objekt vom Typ \lstinline|T|.
\end{itemize}

\subsection*{std::move}

std::move ist ein Cast, der ein Objekt als "bewegbar" markiert; dies erlaubt dem Compiler, statt einer teuren Kopie eine schnelle Ressourcen-Übernahme durchzuführen, wobei das Originalobjekt in einem gültigen, aber unbestimmten Zustand zurückbleibt und sicher am Ende seines Gültigkeitsbereichs zerstört wird (Wird oft bei \lstinline|unique_ptr| verwendet).

\section{Functional und Lambda}

Benötigt \lstinline|#include <functional>|

\lstinline|std::function<T>| ist nützlich um Funktionen als Objekt zu deklarieren, speichern und übergeben zu können. \algo{Beispiel}: \newline
\lstinline|std::function<int(int,int)> sum = [](int a, int b) { return a + b; };|

\subsection*{Lambda Funktionen}

Lambda Funktionen sind anonyme Funktionen, die direkt im Code definiert werden können. Sie haben die folgende Syntax:

\lstinline|[capture](parameters) -> return_type { body }|

\begin{itemize}
    \item \textbf{Capture}: Bestimmt, welche Variablen aus dem umgebenden Kontext verwendet werden können.
    \begin{itemize}
        \item \lstinline|[]|: Keine Variablen werden erfasst.
        \item \lstinline|[=]|: Alle Variablen werden per Wert erfasst.
        \item \lstinline|[&]|: Alle Variablen werden per Referenz erfasst.
        \item \lstinline|[x, &y]|: Variable \lstinline|x| wird per Wert und \lstinline|y| per Referenz erfasst.
    \end{itemize}
    \item \textbf{Parameters}: Die Parameter der Lambda Funktion, ähnlich wie bei normalen Funktionen.
    \item \textbf{Return Type}: Der Rückgabetyp der Funktion. Kann oft weggelassen werden, da der Compiler ihn ableiten kann.
    \item \textbf{Body}: Der eigentliche Code der Funktion, eingeschlossen in geschweifte Klammern.
\end{itemize}












\end{multicols*}
\end{document}
